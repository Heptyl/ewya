
#define LOG_NDEBUG 0
#define XBH_LOG_TAG "xbh_mw@ChipLt8711"
#include "XbhLog.h"

#include <cutils/properties.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include "ChipLt8711.h"
#include "XbhService.h"


XbhMutex                       ChipLt8711::mLock;

#define Flash_Addr_CRC              0x007FFF
#define CRC_Val                     0x5A
#define FW_FLASH_ADDR               0x00
#define HDCP_KEY_FLASH_ADDR         0x50000
#define MAX_UX_FIRMWARE_LENGTH      (0x6000)

#define MAJOR_VERSION       0x01
#define MIDDLE_VERSION      0x00
#define MINOR_VERSION       0x02

#define MAX_DATA_LENGTH (32 * 1024)    //buffer最大长度，升级文件大小不超过1M
#define MAX_KEY_LENGTH  1024           //最大key长度

static unsigned char g_data_buffer[MAX_DATA_LENGTH]={0};
static unsigned int  g_data_buffer_len = 0;
static unsigned char g_lt8711_readkey_flag = 0;
static unsigned char g_lt8711_loadkey_flag = 0;
static unsigned int  g_lt8711_flash_addr = 0;
static unsigned int  g_lt8711_count=0;
static unsigned int  g_download_check_count = 0;
static unsigned char g_lt8711_read_key[MAX_KEY_LENGTH] = {0}; //存放读取到的KEY
static unsigned char g_crc_val = 0;

static unsigned char g_lt8711_key[MAX_KEY_LENGTH] = 
{
0xDE,0x99,0xD5,0xBA,0xDC,0xD8,0x51,0x87,0x81,0xF1,0x47,0x5D,0xBE,0x00,0x09,0xE4,
0x5D,0x1C,0xCA,0xDE,0x8D,0x4C,0x0F,0x57,0x07,0x05,0x69,0x36,0xB9,0x95,0x4A,0x53,
0xB2,0x2D,0xCA,0x3C,0x18,0x7F,0x70,0xA1,0x43,0x15,0xDD,0xC2,0xFE,0xBD,0x1D,0xEA,
0xD6,0xD4,0x11,0x70,0xBB,0xB8,0x15,0x72,0x45,0x9C,0x42,0x22,0x53,0x65,0x2B,0xE1,
0x83,0xE1,0x73,0x9B,0x0D,0x9D,0x22,0x65,0xD9,0x95,0xF3,0x46,0xBB,0x7C,0xE4,0x91,
0x0F,0x60,0x6C,0x35,0xB4,0xB4,0x38,0x1E,0xCC,0xC9,0x04,0x64,0xBB,0xD3,0x50,0x38,
0xC0,0x10,0x01,0xAD,0xC7,0xB0,0x18,0x63,0x9B,0x48,0x8C,0xCF,0xF2,0xB1,0x50,0x90,
0xBD,0xDE,0xF9,0x0D,0x93,0xF2,0x62,0xDA,0xA0,0xE1,0x9B,0xA7,0x6D,0x98,0x6E,0xAD,
0x48,0x34,0xD0,0x7B,0xF2,0x5C,0x05,0x77,0xCD,0x70,0x4F,0x92,0x22,0xD4,0xE8,0xCE,
0xB4,0x46,0xCC,0xDA,0xE3,0x5E,0xC2,0xC8,0xEC,0x65,0xE2,0xE9,0x50,0xF8,0xEF,0x7E,
0x3D,0x8E,0x49,0xEF,0x51,0xD4,0xFC,0xCE,0xFF,0x0A,0x90,0xD2,0x58,0xF9,0xCA,0xE6,
0xCE,0x00,0x63,0xD5,0xCD,0x48,0x9D,0x04,0x5B,0x6A,0x37,0xE1,0xA7,0x65,0xD1,0x20,
0xBE,0x92,0x22,0xF8,0x0C,0xE9,0x21,0x13,0x9A,0xA7,0x7D,0x3B,0x14,0x36,0xA6,0x55,
0x0E,0x78,0x80,0x33,0xA1,0x8C,0xDA,0x85,0x97,0xAE,0x76,0xCA,0x9F,0x1F,0x60,0x2F,
0x29,0xB0,0x02,0x85,0x96,0xC4,0x41,0xEE,0xDC,0xFF,0x0F,0xC1,0xFE,0x46,0x18,0xA0,
0xA7,0xA6,0x49,0x75,0x1E,0x3E,0x90,0xA9,0x08,0x15,0xFD,0x93,0x44,0x9F,0x64,0x4C,
0xC6,0x39,0xF4,0xA2,0xEC,0x07,0x15,0xFA,0xCC,0xE7,0xFB,0xD8,0x43,0x97,0x62,0x47,
0x6E,0x57,0x5F,0x65,0x61,0xA6,0xF4,0xF6,0xC3,0xAC,0xC5,0xBB,0xE6,0xF9,0xA0,0xB4,
0x3F,0xD9,0xCA,0xC6,0xA1,0xA8,0x45,0x6D,0x43,0xF7,0x9A,0xBD,0x23,0x5F,0x7C,0xAF,
0x9D,0x5F,0x40,0x33,0xBE,0xDE,0x5A,0x06,0xE7,0xF5,0x04,0x64,0x37,0x8E,0xFE,0x6D,
0x51,0x73,0xBF,0x77,0xF3,0x1F,0xF7,0x6A,0xC1,0xEE,0x63,0x6D,0x55,0x50,0xFA,0x61,
0x76,0x2D,0xAE,0xEB,0xC1,0xDA,0x94,0xEE,0xC5,0xEF,0x67,0xB8,0xE9,0x15,0xB9,0x85,
0x06,0x01,0xA4,0x07,0xD0,0xA5,0xC4,0xBB,0x5A,0xF8,0x1B,0xCD,0x97,0x91,0x39,0xAE,
0x05,0x32,0xD5,0x23,0x67,0xBF,0x86,0x0F,0x86,0xE2,0x70,0xFB,0xB3,0x96,0x67,0x5A,
0xBF,0x55,0xED,0x74,0x82,0x9A,0x66,0x25,0xDA,0x48,0x60,0xB1,0x70,0x96,0x29,0x2F,
0xC5,0x7F,0xFF,0x29,0x29,0xCA,0x28,0xE1,0xF3,0xFB,0x95,0xE2,0xDC,0xB0,0x13,0x97,
0xDC,0x08,0x01,0x7C,0xAB,0x13,0x3B,0x93,0x1C,0x94,0xC8,0xF2,0x36,0x95,0xB7,0x96,
0x01,0x9A,0xC3,0xB4,0x20,0xDB,0x11,0xD4,0x94,0x44,0xBA,0x5C,0x20,0xE0,0x47,0xE0,
0xEF,0x89,0x7B,0x52,0x10,0x07,0x96,0x64,0xD6,0x30,0x28,0xD6,0x8E,0xC6,0xBE,0x93,
0xDE,0xF4,0x39,0x04,0xD9,0xC8,0xB5,0xF1,0x85,0x41,0x28,0x29,0x8C,0x32,0x72,0xDC,
0x08,0x51,0xB7,0x0D,0x05,0x93,0x30,0x78,0x4D,0x27,0xF8,0x64,0x34,0x0C,0x3B,0x7D,
0xA0,0xBB,0xAB,0x6D,0x43,0x78,0x98,0x84,0xD7,0xC4,0xE7,0x49,0x66,0xA9,0x3A,0xC3,
0xAE,0x40,0x0C,0x5B,0x7B,0xE9,0x0D,0xAD,0x84,0x42,0x40,0x81,0x5A,0x19,0x6C,0x18,
0x88,0xB6,0x6B,0xCC,0xD3,0xDA,0x85,0xA8,0x88,0x6A,0xFD,0x8A,0x6A,0xA0,0x45,0x60,
0x1D,0x95,0xA3,0x2C,0x36,0x2F,0xAD,0x2F,0xEC,0xD7,0xEF,0x8C,0xFD,0x89,0x61,0x0D,
0x14,0x2B,0x72,0x42,0x05,0x6A,0xBB,0xB3,0x8C,0xB2,0x35,0x6C,0x2F,0xC0,0x74,0xAC,
0x3F,0x8F,0x99,0x3B,0x92,0xD2,0xAD,0x6E,0xAE,0xCB,0x0A,0x55,0x45,0xEF,0x28,0xFC,
0x1D,0x8A,0x08,0xC6,0x08,0xC2,0x81,0x3D,0xAE,0x71,0x90,0xA4,0xD3,0x9C,0x84,0xC5,
0x84,0xBE,0x55,0x14,0x15,0xE7,0x1B,0x0C,0x47,0xA2,0x0B,0x4A,0x33,0x5E,0x4B,0xBA,
0xF7,0x95,0xD5,0x16,0x09,0xA6,0xAC,0x06,0xFE,0x05,0xE1,0x22,0xDC,0x6D,0xE4,0xE2,
0xC9,0x39,0x5D,0xDD,0x3D,0x74,0x51,0x7D,0xA9,0xB2,0x1D,0x93,0xA3,0x8B,0xCB,0x7C,
0xCB,0x6B,0xA1,0x5B,0x49,0x54,0xCE,0xCE,0x40,0x83,0xFF,0x7E,0xCC,0xE0,0x63,0x45,
0x85,0x06,0xCD,0x9B,0x0B,0xC7,0xAF,0xD6,0x25,0x70,0xB2,0xAC,0xAE,0xDF,0x7C,0xF6,
0x40,0x1F,0x24,0x30,0x30,0xF1,0xF9,0x83,0x59,0xFE,0xF9,0x59,0xE9,0xEB,0x07,0xEE,
0xCC,0x0D,0x51,0x9E,0xA0,0x65,0x6B,0x54,0xFC,0x38,0xBC,0x00,0x7F,0xCA,0xA0,0x69,
0xF5,0x9C,0xA6,0x44,0x3C,0x23,0x5C,0xFB,0xBB,0x5F,0xCD,0x2C,0xDD,0x66,0x9D,0x91,
0x9B,0x1A,0xB5,0xFA,0xC9,0x2D,0x2B,0xD6,0xA7,0xE3,0xAE,0x3B,0xA1,0x4E,0xC2,0xE3,
0x79,0x06,0x4A,0xD9,0xA8,0x9B,0xBF,0x2E,0x2E,0x83,0x3B,0x80,0x2F,0x9F,0x1E,0xA8,
0x32,0x23,0xD1,0x76,0xE6,0xAE,0x12,0x3A,0x16,0x3B,0x44,0x2A,0xA4,0xBC,0xCC,0x89,
0x6C,0xB4,0x15,0x49,0x47,0x3E,0xB9,0x87,0x41,0x67,0x38,0x38,0xAA,0x01,0xE6,0x1E,
0x57,0x58,0xFD,0xBB,0x15,0x43,0x40,0x29,0x93,0xF2,0xAB,0xEC,0xE9,0xF2,0x78,0x68,
0x0F,0xC8,0xEF,0x09,0x26,0x2C,0xA0,0xE9,0xA4,0x78,0x37,0x11,0x89,0x01,0x2F,0x82,
0xAC,0xA3,0xC3,0x72,0x1E,0xBF,0x9C,0x02,0x65,0x1A,0x6E,0xB5,0x2D,0x70,0xE1,0x6E,
0x82,0x74,0x6C,0x5E,0x7C,0x2A,0xA9,0x0E,0xEC,0xFB,0xAB,0xE2,0xBC,0xBA,0x76,0x23,
0x60,0x48,0x5F,0xA1,0x1E,0x27,0xFD,0xF7,0x75,0x27,0xA2,0x46,0x65,0xA0,0x31,0x24,
0x81,0xEF,0xDC,0x05,0xA2,0x30,0x5F,0x31,0x31,0xD6,0x12,0xBE,0xAD,0x1C,0x29,0x71,
0x13,0xA2,0x8A,0xFA,0xB5,0x89,0xCF,0x2A,0x4E,0x1B,0x5D,0xF4,0xAD,0xA1,0xBB,0x39,
0xB0,0x90,0x3B,0x96,0x6E,0x2A,0xC6,0x84,0x38,0xE4,0xA1,0xD1,0xB1,0x1A,0xF6,0xBB,
0x30,0x95,0x1A,0x4C,0x79,0x05,0x6D,0xC8,0x66,0xB7,0x13,0x0A,0x0D,0x95,0xA6,0xA0,
0x76,0x56,0xBB,0xEB,0xE8,0x3E,0x59,0xAC,0xE3,0x6E,0x86,0x08,0x85,0x85,0x85,0x85,
0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85
};

//---------------- custom device interface start ----------------
/**
 * 复位当前转换芯片
 */
XBH_S32 ChipLt8711::resetChip()
{
    XBH_S32 s32Ret = XBH_FAILURE;
    if (mRGpio != -1) {
        XbhService::getModuleInterface()->setGpioOutputValue(mRGpio, !mRLevel);
        usleep(50 * 1000);
        XbhService::getModuleInterface()->setGpioOutputValue(mRGpio, mRLevel);
    }
    return s32Ret;
}

/**
 * 设置当前信源的HPD状态
 * value 高低状态
 */
XBH_S32 ChipLt8711::setRxHpd(XBH_U8 value)
{
    XBH_S32 s32Ret = XBH_FAILURE;
    return s32Ret;
}

/**
 * 获取固件版本
 */
XBH_S32 ChipLt8711::getFirmwareVersion(XBH_CHAR* strVersion)
{
    //TODO 初步移植，尚未搭建硬件环境验证
    XBH_S32 s32Ret = XBH_SUCCESS;
    if(strVersion == XBH_NULL) {
        XLOGD("===> getFirmwareVersion strVersion is NULL");
        return XBH_FAILURE;
    }
    if (mState == LT8711_RUNNING)
    {
        XLOGW("Warning: ite8711 is updating...");
        return XBH_FAILURE;
    }
    unsigned char version_info[3] = {0};
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);
    i2c_data_write(0xff, 0x99);
    i2c_data_read(0x43, 1, version_info, 3);
    XLOGD("===> checkVersion version [%02X %02X %02X]!\n", version_info[0], version_info[1], version_info[2]);
    sprintf(strVersion, "%02X%02X%02X", version_info[0], version_info[1], version_info[2]);
    return s32Ret;
}

/**
 * 进行固件升级
 */
XBH_S32 ChipLt8711::upgradeFirmware(const XBH_CHAR* strFilePath, XBH_BOOL bForceUpgrade)
{
    //TODO 初步移植，尚未搭建硬件环境验证
    if (mState == LT8711_RUNNING)
    {
        XLOGW("Warning: lt8711 is updating...");
        return XBH_SUCCESS;
    }

    if (strFilePath == XBH_NULL)
    {
        XLOGE("Error: fileName is XBH_NULL");
        return XBH_FAILURE;
    }

    //set force upgrade flag
    mForceUpgrade = bForceUpgrade;
    //mI2cNum = I2C_CHANNEL;

    //set upgrade file name
    memset(mFileName, 0x00, sizeof(mFileName));
    if (strlen(strFilePath) >= sizeof(mFileName))
    {
        XLOGE("Error: fileName is too long: %d", strlen(strFilePath));
        return XBH_FAILURE;
    }
    strncpy(mFileName, strFilePath, strlen(strFilePath));

    XbhMWThread::run(XbhMWThread::ONCE);
    return XBH_SUCCESS;
}

/**
 * 获取当前升级的进度
 */
XBH_S32 ChipLt8711::getUpgradeState(XBH_S32 * s32State)
{
    XBH_S32 s32Ret = XBH_FAILURE;
    *s32State = mState;
    return s32Ret;
}

XBH_S32 ChipLt8711::getChipExist(XBH_BOOL* enable)
{
    XBH_S32 s32Ret = XBH_FAILURE;
    XLOGE("%s %d \n",__func__,__LINE__);
    unsigned char chip_id[2] = {0};
    s32Ret |= i2c_data_write(0xff, 0x80);
    s32Ret |= i2c_data_write(0xee, 0x01);
    s32Ret |= i2c_data_write(0xff, 0x81);
    s32Ret |= i2c_data_read(0x00, 1, chip_id, 2);
    XLOGD("===> lt8711 chip_id = [0x%02X%02X]!\n",chip_id[0], chip_id[1]);
    if(chip_id[0] != 0x16 ||  chip_id[1] != 0x07)
    {
        XLOGE("===> Find chip fail");
        *enable = XBH_FALSE;
    }else{
        XLOGE("===> Find chip ok");
        *enable = XBH_TRUE;
    }
    return s32Ret;
}

XBH_S32 ChipLt8711::getChipInitDone(XBH_BOOL* enable)
{
    XBH_S32 s32Ret = XBH_FAILURE;
    return s32Ret;
}

XBH_S32 ChipLt8711::i2c_data_read(unsigned int u32RegAddr, unsigned int RegAddrLen, unsigned char *p_data, unsigned int data_len)
{
    XBH_S32 s32Ret = XBH_SUCCESS;
    s32Ret = XbhService::getModuleInterface()->getI2cData(mI2cNum, mI2cAddr, u32RegAddr, RegAddrLen, data_len, p_data);
    return s32Ret;
}

XBH_S32 ChipLt8711::i2c_data_write(unsigned char u8RegAddr, unsigned char reg_value)
{
    XBH_S32 s32Ret = XBH_SUCCESS;
    s32Ret = XbhService::getModuleInterface()->setI2cData(mI2cNum, mI2cAddr, u8RegAddr, 1, 1, &reg_value);
    return s32Ret;
}

XBH_S32 ChipLt8711::i2c_data_write_nbytes(unsigned int u32RegAddr, unsigned int RegAddrLen, unsigned char *p_data, unsigned int data_len)
{
    XBH_S32 s32Ret = XBH_SUCCESS;
    s32Ret = XbhService::getModuleInterface()->setI2cData(mI2cNum, mI2cAddr, u32RegAddr, RegAddrLen, data_len, p_data);
    return s32Ret;
}

//逐个字节比较
XBH_S32 ChipLt8711::lt8711_read_byte_compare(unsigned int u32RegAddr, unsigned int RegAddrLen, unsigned char *p_data, unsigned int data_len)
{
    XBH_S32 s32Ret = XBH_SUCCESS;
    unsigned char *buffer = (unsigned char *)malloc(data_len*sizeof(unsigned char));
    s32Ret = XbhService::getModuleInterface()->getI2cData(mI2cNum, mI2cAddr, u32RegAddr, RegAddrLen, data_len, buffer);
    for(int i = 0; i < data_len; i++)
    {
        if(buffer[i] != p_data[i]) //如果数据不同
        {
            g_download_check_count++;
        }
            
    }
    free(buffer);
    buffer = NULL;
    return s32Ret;
}

XBH_S32 ChipLt8711::lt8711_init(const char *upgrade_file_path)
{
    XBH_S32 s32Ret = XBH_FAILURE;
    XLOGD("\n===> %s\n",__FUNCTION__);

    FILE *fp = XBH_NULL;
    fp = fopen(upgrade_file_path, "r");
    if(fp != XBH_NULL)
    {
        fseek(fp,0,SEEK_END);
        g_data_buffer_len = ftell(fp);        //计算文件大小
        fseek(fp,0,SEEK_SET);
        XLOGD("==> read upgrade file size:%d\n",g_data_buffer_len);
        if(g_data_buffer_len < MAX_DATA_LENGTH)
        {
            fread(g_data_buffer, 1, g_data_buffer_len, fp);
            s32Ret = XBH_SUCCESS;
        }
        else
            XLOGE("==> upgrade file size more than %d bytes.\n",MAX_DATA_LENGTH);
        fclose(fp);
    }

    if (g_data_buffer_len > MAX_UX_FIRMWARE_LENGTH){
        XLOGE("==> Please check if the firmware is correct.\n");
        s32Ret = XBH_FAILURE;
    }

    return s32Ret;
}

XBH_S32 ChipLt8711::lt8711_load_code_to_flash(void)
{
    XLOGD("\n===> %s\n",__FUNCTION__);
    lt8711_i2c_to_flash_config();   //写入配置

    lt8711_read_key();              //读取key

    lt8711_flash_block_erase();     //擦除flash

    lt8711_download_core();         //下载代码

    if(g_lt8711_readkey_flag)
    {
        lt8711_download_key(g_lt8711_read_key);
        usleep(10*1000);
        lt8711_read_key_compare(g_lt8711_read_key);
    }
    else
    {
        lt8711_download_key(g_lt8711_key);
        usleep(10*1000);
        lt8711_read_key_compare(g_lt8711_key);
    }
    usleep(10*1000);
    
    if(XBH_SUCCESS != lt8711_read_flash()) {
        return XBH_FAILURE;
    }

    return XBH_SUCCESS;
}

XBH_S32 ChipLt8711::lt8711_flash_block_erase()
{
    XBH_S32 s32Ret = XBH_SUCCESS;
    XLOGD("\n===> %s\n",__FUNCTION__);
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);
    
    i2c_data_write(0xff, 0x98);
    i2c_data_write(0xee, 0x01);
    
    i2c_data_write(0x5a, 0x86);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x5b, 0x00);
    i2c_data_write(0x5c, 0x00);
    i2c_data_write(0x5d, 0x00);
    i2c_data_write(0x5a, 0x83);
    i2c_data_write(0x5a, 0x82);

    usleep(3000*1000);
    return s32Ret;
}

XBH_S32 ChipLt8711::lt8711_i2c_to_flash_config(void)
{
    XBH_S32 s32Ret = XBH_SUCCESS;
    XLOGD("\n===> %s\n",__FUNCTION__);
    //iic setting
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);
    i2c_data_write(0xff, 0x81);
    i2c_data_write(0x05, 0x22);

    //config parameter
    i2c_data_write(0xff, 0x98);
    i2c_data_write(0xee, 0x01);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x5e, 0xc0);
    i2c_data_write(0x58, 0x00);
    i2c_data_write(0x59, 0x51);
    i2c_data_write(0x5a, 0x92);
    i2c_data_write(0x5a, 0x82);
    usleep(2*1000);
    return s32Ret;
}

XBH_S32 ChipLt8711::lt8711_download_core(void)
{
    XLOGD("\n===> %s\n",__FUNCTION__);
    unsigned  addr1,addr2,addr3;
    g_lt8711_flash_addr = 0;
    g_lt8711_count = 0;
    
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);

    while( (g_lt8711_count+16) < g_data_buffer_len)
    {
        addr1=g_lt8711_flash_addr;
        addr2=g_lt8711_flash_addr>>8;
        addr3=g_lt8711_flash_addr>>16;
        i2c_data_write(0xff, 0x98);
        i2c_data_write(0x5a, 0x86);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x5e, 0xef);
        i2c_data_write(0x5a, 0xa2);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x58, 0x01);
        i2c_data_write_nbytes(0x59, 1, g_data_buffer + g_lt8711_count, 16);
        i2c_data_write(0x5b, addr3);
        i2c_data_write(0x5c, addr2);
        i2c_data_write(0x5d, addr1);
        i2c_data_write(0x5e, 0xe0);
        i2c_data_write(0x5a, 0x92);
        i2c_data_write(0x5a, 0x82);
        g_lt8711_flash_addr = g_lt8711_flash_addr+0x10;
        g_lt8711_count = g_lt8711_count + 16;
    }
    addr1=g_lt8711_flash_addr;
    addr2=g_lt8711_flash_addr>>8;
    addr3=g_lt8711_flash_addr>>16;
    
    i2c_data_write(0x5a, 0x86);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x5e, 0xef);
    i2c_data_write(0x5a, 0xa2);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x58, 0x01);

    i2c_data_write_nbytes(0x59, 1, g_data_buffer + g_lt8711_count, g_data_buffer_len - g_lt8711_count);
    
    i2c_data_write(0x5b, addr3);
    i2c_data_write(0x5c, addr2);
    i2c_data_write(0x5d, addr1);
    i2c_data_write(0x5e, 0xe0);
    i2c_data_write(0x5a, 0x92);
    i2c_data_write(0x5a, 0x82);

    i2c_data_write(0x5a, 0x8a);
    i2c_data_write(0x5a, 0x82);

    //fifo rst_n
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0x02, 0xbf);
    i2c_data_write(0x02, 0xff);
    return XBH_SUCCESS;
}

XBH_S32 ChipLt8711::lt8711_read_flash(void)
{
    XBH_S32 s32Ret = XBH_FAILURE;
    XLOGD("\n===> %s\n",__FUNCTION__);
    unsigned char addr1,addr2,addr3;
    g_lt8711_flash_addr=0;
    g_lt8711_count=0;
    g_download_check_count=0;

    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);
    i2c_data_write(0xff, 0x98);
    i2c_data_write(0xee, 0x01);
    //wren
    i2c_data_write(0x5a, 0x86);
    i2c_data_write(0x5a, 0x82);
    while((g_lt8711_count+16)<g_data_buffer_len)
    {
        addr1=g_lt8711_flash_addr;
        addr2=g_lt8711_flash_addr>>8;
        addr3=g_lt8711_flash_addr>>16;
        i2c_data_write(0x5e, 0x6f);
        i2c_data_write(0x5a, 0xa2);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x5b, addr3);
        i2c_data_write(0x5c, addr2);
        i2c_data_write(0x5d, addr1);
        i2c_data_write(0x5a, 0x92);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x58, 0x01);

        lt8711_read_byte_compare(0x5f, 1, g_data_buffer+g_lt8711_count, 16);

        g_lt8711_flash_addr = g_lt8711_flash_addr+0x10;
        g_lt8711_count = g_lt8711_count+16;
    }
    addr1=g_lt8711_flash_addr;
    addr2=g_lt8711_flash_addr>>8;
    addr3=g_lt8711_flash_addr>>16;
    i2c_data_write(0x5e, 0x6f);
    i2c_data_write(0x5a, 0xa2);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x5b, addr3);
    i2c_data_write(0x5c, addr2);
    i2c_data_write(0x5d, addr1);
    i2c_data_write(0x5a, 0x92);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x58, 0x01);

    lt8711_read_byte_compare(0x5f, 1, g_data_buffer+g_lt8711_count, g_data_buffer_len-g_lt8711_count);

    //fifo rst_n
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0x02, 0xbf);
    usleep(200);
    i2c_data_write(0x02, 0xff);
    if(g_download_check_count == 0)
    {
        s32Ret = XBH_SUCCESS;
        XLOGD("\n===> UXE lt8711_read_flash  Download Code Success!!\n");
    }
    else
    {
        mState = LT8711_FAILURE;
        s32Ret = XBH_FAILURE;
        XLOGD("\n===> UXE lt8711_read_flash  Download Code Fail!!\n");
    }
    return s32Ret;
}

XBH_S32 ChipLt8711::lt8711_read_key()
{
    XLOGD("\n===> %s\n",__FUNCTION__);
    unsigned int i;
    unsigned char Key_Chenck_Sum=0;
    unsigned char addr1,addr2,addr3;
    
    g_lt8711_flash_addr = 0x006000;
    g_lt8711_count=0;
    
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);
    i2c_data_write(0xff, 0x98);
    i2c_data_write(0xee, 0x01);
    
    //wren
    i2c_data_write(0x5a, 0x86);
    i2c_data_write(0x5a, 0x82);
    
    while( (g_lt8711_count+16) < MAX_KEY_LENGTH )
    {
        addr1=g_lt8711_flash_addr;
        addr2=g_lt8711_flash_addr>>8;
        addr3=g_lt8711_flash_addr>>16;
        
        i2c_data_write(0x5e, 0x6f);
        i2c_data_write(0x5a, 0xa2);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x5b, addr3);
        i2c_data_write(0x5c, addr2);
        i2c_data_write(0x5d, addr1);
        i2c_data_write(0x5a, 0x92);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x58, 0x01);
        i2c_data_read(0x5f, 1, g_lt8711_read_key+g_lt8711_count, 16);

        g_lt8711_flash_addr = g_lt8711_flash_addr+0x10;
        g_lt8711_count = g_lt8711_count+16;
    }
    addr1=g_lt8711_flash_addr;
    addr2=g_lt8711_flash_addr>>8;
    addr3=g_lt8711_flash_addr>>16;
    i2c_data_write(0x5e, 0x6f);
    i2c_data_write(0x5a, 0xa2);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x5b, addr3);
    i2c_data_write(0x5c, addr2);
    i2c_data_write(0x5d, addr1);
    i2c_data_write(0x5a, 0x92);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x58, 0x01);
    i2c_data_read(0x5f, 1, g_lt8711_read_key+g_lt8711_count, MAX_KEY_LENGTH-g_lt8711_count);

    //fifo rst_n
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0x02, 0xbf);
    usleep(200);
    i2c_data_write(0x02, 0xff);
    
    for(i=0;i<MAX_KEY_LENGTH;i++)
    {
        Key_Chenck_Sum = Key_Chenck_Sum + (g_lt8711_read_key[i]^0x85);
    }
    
    if(Key_Chenck_Sum==0)
    {
        g_lt8711_readkey_flag = 1;
        XLOGD("\n===> LT8711 Read Key Correct!\n");
    }
    else
    {
        g_lt8711_readkey_flag = 0;
        XLOGE("\n===> LT8711 Read Key Incorrect!\n");
    }
    return XBH_SUCCESS;
}

XBH_S32 ChipLt8711::lt8711_download_key(unsigned char *Data)
{
    XLOGD("\n===> %s\n",__FUNCTION__);
    unsigned char addr1,addr2,addr3;
    g_lt8711_flash_addr = 0x006000;
    g_lt8711_count = 0;
    
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);

    while((g_lt8711_count+16)<MAX_KEY_LENGTH)
    {
        addr1=g_lt8711_flash_addr;
        addr2=g_lt8711_flash_addr>>8;
        addr3=g_lt8711_flash_addr>>16;
        i2c_data_write(0xff, 0x98);
        i2c_data_write(0x5a, 0x86);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x5e, 0xef);
        i2c_data_write(0x5a, 0xa2);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x58, 0x01);
        
        i2c_data_write_nbytes(0x59, 1, Data+g_lt8711_count, 16);
        
        i2c_data_write(0x5b, addr3);
        i2c_data_write(0x5c, addr2);
        i2c_data_write(0x5d, addr1);
        i2c_data_write(0x5e, 0xe0);
        i2c_data_write(0x5a, 0x92);
        i2c_data_write(0x5a, 0x82);

        g_lt8711_flash_addr = g_lt8711_flash_addr + 0x10;
        g_lt8711_count = g_lt8711_count + 16;
    }
    
    addr1=g_lt8711_flash_addr;
    addr2=g_lt8711_flash_addr>>8;
    addr3=g_lt8711_flash_addr>>16;
    i2c_data_write(0x5a, 0x86);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x5e, 0xef);
    i2c_data_write(0x5a, 0xa2);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x58, 0x01);
    
    i2c_data_write_nbytes(0x59, 1, Data+g_lt8711_count, MAX_KEY_LENGTH-g_lt8711_count);
    
    i2c_data_write(0x5b, addr3);
    i2c_data_write(0x5c, addr2);
    i2c_data_write(0x5d, addr1);
    i2c_data_write(0x5e, 0xe0);
    i2c_data_write(0x5a, 0x92);
    i2c_data_write(0x5a, 0x82);

    i2c_data_write(0x5a, 0x8a);
    i2c_data_write(0x5a, 0x82);
    //fifo rst_n
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0x02, 0xbf);
    i2c_data_write(0x02, 0xff);
    return XBH_SUCCESS;
}

//比较key
XBH_S32 ChipLt8711::lt8711_read_key_compare(unsigned char *Data)
{
    XLOGD("\n===> %s\n",__FUNCTION__);
    unsigned char addr1,addr2,addr3;
    g_lt8711_flash_addr=0x006000;
    g_lt8711_count=0;
    g_download_check_count = 0;
    
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);
    i2c_data_write(0xff, 0x98);
    i2c_data_write(0xee, 0x01);

    //wren
    i2c_data_write(0x5a, 0x86);
    i2c_data_write(0x5a, 0x82);
    
    while( (g_lt8711_count+16) < MAX_KEY_LENGTH )
    {
        addr1=g_lt8711_flash_addr;
        addr2=g_lt8711_flash_addr>>8;
        addr3=g_lt8711_flash_addr>>16;
        i2c_data_write(0x5e, 0x6f);
        i2c_data_write(0x5a, 0xa2);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x5b, addr3);
        i2c_data_write(0x5c, addr2);
        i2c_data_write(0x5d, addr1);
        i2c_data_write(0x5a, 0x92);
        i2c_data_write(0x5a, 0x82);
        i2c_data_write(0x58, 0x01);
        
        lt8711_read_byte_compare(0x5f, 1, Data+g_lt8711_count, 16);

        g_lt8711_flash_addr = g_lt8711_flash_addr+0x10;
        g_lt8711_count = g_lt8711_count+16;
    }
    addr1=g_lt8711_flash_addr;
    addr2=g_lt8711_flash_addr>>8;
    addr3=g_lt8711_flash_addr>>16;

    i2c_data_write(0x5e, 0x6f);
    i2c_data_write(0x5a, 0xa2);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x5b, addr3);
    i2c_data_write(0x5c, addr2);
    i2c_data_write(0x5d, addr1);
    i2c_data_write(0x5a, 0x92);
    i2c_data_write(0x5a, 0x82);
    i2c_data_write(0x58, 0x01);

    lt8711_read_byte_compare(0x5f, 1, Data+g_lt8711_count, MAX_KEY_LENGTH-g_lt8711_count);

    //fifo rst_n
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0x02, 0xbf);

    usleep(200);

    i2c_data_write(0x02, 0xff);
    if(g_download_check_count == 0)
    {
        g_lt8711_loadkey_flag = 1;
        XLOGD("\n===> lt8711 Download Key Success!!\n");
    }
    else
    {
        g_lt8711_loadkey_flag = 0;
        XLOGE("\n===> lt8711 Download Key Fail!!\n");
    }
    return XBH_SUCCESS;
}

XBH_S32 ChipLt8711::lt8711_uninit(void)
{
    XLOGD("\n===> %s\n",__FUNCTION__);
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);
    i2c_data_write(0xff, 0x97);
    i2c_data_write(0x43, 0x5d);
    return XBH_SUCCESS;
}

XBH_S32 ChipLt8711::checkVersion()
{
    XBH_S32 s32Ret = XBH_SUCCESS;
    unsigned char version_info[3] = {0};
    i2c_data_write(0xff, 0x80);
    i2c_data_write(0xee, 0x01);
    i2c_data_write(0xff, 0x99);
    i2c_data_read(0x43, 1, version_info, 3);
    XLOGD("===> checkVersion version [%02X %02X %02X]!\n", version_info[0], version_info[1], version_info[2]);

    if(version_info[0] == MAJOR_VERSION &&
        version_info[1] == MIDDLE_VERSION &&
        version_info[2] == MINOR_VERSION )  //版本一致无需升级
    {
        if(!mForceUpgrade) //未开启强制升级
        {
            XLOGD("\nThis program is already up-to-date and does not need to be upgraded.\n");
            return XBH_FAILURE;
        }
        else
            XLOGE("\nThis program is already up-to-date,but force upgrade flag is opened, continue upgrade...\n");
    }
    return s32Ret;
}

void ChipLt8711::run(const void* arg)
{
    XBH_S32 s32Ret = XBH_FAILURE;
    XBH_S32 s32State = XBH_FALSE;

    mState = LT8711_RUNNING; //set task status

    s32Ret = lt8711_init(mFileName);
    if(XBH_SUCCESS != s32Ret){
        XLOGE("\n===> %s init fail, file:%s\n",__FUNCTION__, mFileName);
        mState = LT8711_FAILURE;
        return;
    }
    
    getChipExist((XBH_BOOL*)&s32State);
    if(XBH_TRUE != s32State){ //读chip ID
        XLOGE("\n===> %s get chip id fail!\n",__FUNCTION__);
        lt8711_uninit();
        mState = LT8711_FAILURE;
        return;
    }

    if(XBH_SUCCESS != checkVersion()){ //获取版本信息
        XLOGE("\n===> %s get version fail!\n",__FUNCTION__);
        lt8711_uninit();
        mState = LT8711_FAILURE;
        return;
    }

    //允许升级
    if(XBH_SUCCESS != lt8711_load_code_to_flash()){ //升级固件
        XLOGE("\n===> %s load code to flash fail!\n",__FUNCTION__);
        lt8711_uninit();
        mState = LT8711_FAILURE;
        return;
    }

    lt8711_uninit();
    mState = LT8711_SUCCESS;
}

//---------------- custom device interface end ----------------

ChipLt8711::ChipLt8711(XBH_U32 i2cBus, XBH_U32 Addr, XBH_S32 pGpio, XBH_S32 pLevel, XBH_S32 rGpio, XBH_S32 rLevel)
{
    XLOGD(" begin ");
    mState = LT8711_IDLE;
    mForceUpgrade = XBH_FALSE;

    mI2cNum = i2cBus;
    mI2cAddr = Addr;
    mPGpio = pGpio;
    mPLevel = pLevel;
    mRGpio = rGpio;
    mRLevel = rLevel;

    //power on
    if (mPGpio != -1) {
        XbhService::getModuleInterface()->setGpioOutputValue(mPGpio, mPLevel);
        usleep(50 * 1000);
    }
    //reset
    if (mRGpio != -1) {
        XbhService::getModuleInterface()->setGpioOutputValue(mRGpio, !mRLevel);
        usleep(50 * 1000);
        XbhService::getModuleInterface()->setGpioOutputValue(mRGpio, mRLevel);
    }

    XLOGD(" end ");
}

ChipLt8711::~ChipLt8711()
{

}

